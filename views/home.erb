<% content_for :header do %>

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>

<style type='text/css'>
	body {
		font-family: monaco;
	}

	a {
		color:black;
		text-decoration:underline;
	}

	.counter {
		font-family: 'Open Sans', Arial;
		text-align:right;
		background-color: #fd4;
		border-bottom: 4px solid #4df;
		padding-bottom: 16px;
	}

	.counter .count {
		font-size: 72pt;
		text-align: center;
	}

	.header-line {
		background-color:black; 
		color: #fd4;
		text-align:left; 
		padding: 4px;
		font-weight:bold;
		text-align: center;
	}

	.header-line a {
		color: #fd4;
	}

	.recent-comment {
		padding: 16px;
	}

	.recent-comment a {
		color: black;
	}

	.footer-line {
		text-align:left;
		padding:8px 16px; 
		border-top: 4px solid black;
	}

	@media only screen and (max-width:700px) {
		.counter {
			padding-bottom: 8px;
			padding-top: 4px;
		}

		.counter .count {
			font-size: 36pt;
		}

		.footer-line {
			text-align: center;
		}

		.header-line {
			padding-bottom: 8px;
		}
	}
</style>

<script type='text/javascript'>

class Counter {
	constructor(data) {
		this.data = data;
		this.startTime = Date.now();
	}

	get age() {
		return (this.data.age || 0) + (Date.now() - this.startTime) / 1000;
	}

	get currentValue() {
		return this.data.count + this.data.rate * this.age;
	}
}

class CommentHandler {
	constructor() {
		this.comments = [];
	}

	// this will return the next recent comment. It will refresh the data from the
	// server when it runs out of cached comments. Because it this it always returns
	// a promise, even if it has the data already.
	next() {
		this.comments = this.comments || [];

		if(!this.comments || this.comments.length == 0) {
			return this.getMore().then(comments => {
				this.comments = comments;
				return this.comments.pop();
			});
		} else {
			return Promise.resolve(this.comments.pop());
		}
	}

	getMore() {
		let url = 'https://www.reddit.com/r/all/comments.json?sort=new&limit=20';
		return $.getJSON(url)
			.then(response => { 
				return response.data.children
					.map(c => c.data)
					.filter(c => c.body.length < 140 && !c.body.includes('http'));
			});
	}
}

class App {
	constructor() {
		this.handler = new CommentHandler();
		$('.recent-comment a.refresh-link').click(e => this.updateComment());
	}

	updateComment() {
		this.handler.next().then(comment => {
			$('.recent-comment span').html(comment.body);
			$('.recent-comment a.comment-link')
				.attr('href', `${comment.link_permalink}${comment.id}`);
			$('.recent-comment a.user-link')
				.text(`/u/${comment.author}`)
				.attr('href', `http://reddit.com/u/${comment.author}`);
		});
	}
}

$(document).ready(function() {
	var c = new Counter(_js.comments);
	var t = new Counter(_js.threads);

	(function(){
		$('.comments .count').html(c.currentValue.round().toLocaleString());
		$('.threads .count').html(t.currentValue.round().toLocaleString());
	}).periodical(100);

	const app = new App();
	app.updateComment();
	setInterval(() => app.updateComment(), 10000);
});

</script>

<% end %>

<% content_for :body do %>

<div class='header-line'>how many comments are there on <a href='http://reddit.com'>reddit.com?</a></div>

<div class='comments counter' >
	<div class='count'><%= _js[:comments][:count].to_n0 %></div>
</div>

<div class='recent-comment'>
	<span>...</span> 
	<a class='comment-link' href='#'>&#x21e5</a>
	(<a class='user-link' href='#'>...</a>) 
	<a class='refresh-link' href='#'>&#x21bb;</a>
</div>

<div class='footer-line'>
<a href='http://reednj.com'>@reednj</a> 2017 |
<a href='http://twitter.com/reddit_random'>@reddit_random</a>
</div>

<% end %>
